<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>[App Name Goes Here]</title>
  <style>
    body { font-family: Arial; max-width: 800px; margin: auto; padding: 20px; }
    .page { display: none; }
    .visible { display: block; }
    input, button, select, textarea { width: 100%; font-size: 1rem; padding: 8px; margin: 8px 0; }
    .chip { display: inline-block; background: #eee; padding: 4px 8px; margin: 2px; border-radius: 4px; cursor: pointer;}
    .autocomplete-suggestions { border: 1px solid #ccc; position: absolute; background: white; z-index:1000; max-height:150px; overflow-y:auto; }
    .autocomplete-suggestion { padding: 4px; cursor: pointer; }
    .autocomplete-suggestion:hover { background: #ddd; }
    table { width:100%; border-collapse: collapse; margin-top:20px; }
    th, td { border:1px solid #aaa; padding:8px; text-align:left; }
    .severity { margin-left: 20px; }
    .hidden { display: none; }
    .tag { font-size: 0.8rem; padding: 2px 6px; border-radius: 4px; margin-left: 4px; }
    .safe { background-color: #cce5cc; color: #2e662e; }
    .trigger { background-color: #f8d7da; color: #721c24; }

    /* Modal styles for logs view */
    #logsModal {
      display: none;
      position: fixed;
      top:0; left:0; width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.6);
      z-index: 2000;
      overflow: auto;
    }
    #logsContent {
      background: white;
      max-width: 90vw;
      max-height: 90vh;
      margin: 40px auto;
      padding: 20px;
      border-radius: 8px;
      overflow-y: auto;
    }
    #logsContent h2 {
      margin-top: 0;
    }
    #logsContent button.closeBtn {
      float: right;
      font-size: 1.2rem;
      background: #ddd;
      border: none;
      padding: 4px 12px;
      cursor: pointer;
      border-radius: 4px;
    }
    #logsContent table {
      margin-bottom: 20px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
</head>
<body>

<!-- Welcome Screen -->
<div id="welcome" class="page">
  <h2>Welcome to [Insert App Name Here]</h2>
  <p>Before we begin, please mark any ingredients you already know are safe or trigger foods.</p>
  <label>Search Ingredient:</label>
  <input type="text" id="welcomeInput" placeholder="Start typing..." autocomplete="off" />
  <div id="welcomeSuggestions" class="autocomplete-suggestions"></div>
  <div id="welcomeChips"></div>
  <button onclick="enterApp()">Start Using App</button>
</div>

<!-- Main Navigation -->
<div id="main" class="page">
  <h1>[Insert App Name Here]</h1>
  <button onclick="showPage('logFood')">Log Food</button>
  <button onclick="showPage('logSymptoms')">Log Symptoms</button>
  <!-- New View Logs Button -->
  <button onclick="showLogs()">View Logs</button>
  <!-- Consolidated export button -->
  <button onclick="exportAllCSVs()">Export Logs CSVs</button>
  <button onclick="showPage('settings')">Settings</button>
  <button onclick="showPage('myRecipes')">My Recipies</button>
</div>

<!-- Modal to display logs -->
<div id="logsModal">
  <div id="logsContent">
    <button class="closeBtn" onclick="closeLogs()">Close âœ•</button>
    <h2>Food Logs</h2>
    <div id="foodLogsTableContainer"></div>
    <h2>Symptom Logs</h2>
    <div id="symptomLogsTableContainer"></div>
  </div>
</div>

<!-- Log Food Page -->
<div id="logFood" class="page" style="position:relative;">
  <h2>Log Food</h2>
  <label>Enter ingredients (start typing):</label>
  <input type="text" id="ingredientInput" placeholder="e.g. avocado, bread" autocomplete="off" />
  <div id="suggestions" class="autocomplete-suggestions"></div>
  <div id="chips"></div>
  <label>Or select a saved recipe:</label>
  <select id="recipeDropdown">
    <option value="">--Select a Recipe--</option>
  </select>
  <label>Time eaten:</label>
  <input type="datetime-local" id="foodTime" />
  <button onclick="saveFood()">Save Food</button>
  <button onclick="showPage('main')">Back</button>
</div>

<!-- Log Symptoms Page -->
<div id="logSymptoms" class="page">
  <h2>Log Symptoms</h2>
  <label for="symptomTime">Time symptoms started:</label>
  <input type="datetime-local" id="symptomTime" />
  <div id="symptomContainer"></div>
  <button onclick="saveSymptoms()">Save Symptoms</button>
  <button onclick="showPage('main')">Back</button>
</div>

<!-- Settings Page -->
<div id="settings" class="page">
  <h2>Safe & Trigger Foods</h2>
  <h3>Safe Foods</h3>
  <ul id="safeList"></ul>
  <h3>Trigger Foods</h3>
  <ul id="triggerList"></ul>
  <button onclick="showPage('main')">Back</button>
</div>

<!-- My Recipes Page -->
<div id="myRecipes" class="page" style="position:relative;">
  <h2>My Recipes</h2>
  <label>Recipe Name:</label>
  <input type="text" id="recipeNameInput" placeholder="e.g. Breakfast Smoothie" />
  <label>Ingredients:</label>
  <input type="text" id="recipeIngredientInput" placeholder="e.g. strawberry, yogurt" autocomplete="off" />  
  <div id="recipeSuggestions" class="autocomplete-suggestions"></div>
  <div id="recipeChips"></div>
  <button onclick="saveRecipe()">Save Recipe</button>
  <h3>Saved Recipes</h3>
  <ul id="recipeList"></ul>
  <button onclick="showPage('main')">Back</button>
</div>

<script>
let ingredientList = [], selectedIngredients = [], selectedWelcomeIngredients = [];
let safeFoods = [], triggerFoods = [];

// Load ingredients from CSV
async function loadIngredients() {
  try {
    const response = await fetch('ingredients.csv');
    const csvText = await response.text();
    const results = Papa.parse(csvText, { header: true, skipEmptyLines: true });
    ingredientList = results.data.map(row => row.Description?.toLowerCase()).filter(Boolean);
    setupWelcomeAutocomplete();
    setupMainAutocomplete();
  } catch (error) {
    alert("Error loading ingredient list.");
  }
}
loadIngredients();

// Show a page
function showPage(id) {
  document.querySelectorAll('.page').forEach(p => p.classList.remove('visible'));
  document.getElementById(id).classList.add('visible');
  if (id === "settings") loadSettings();
  if (id === "myRecipes") {
    renderRecipeList();
    setupRecipeAutocomplete();
  }
  if (id === "logFood") populateRecipeDropdown();
}

// Save onboarding choices
function enterApp() {
  localStorage.setItem("safeFoods", JSON.stringify(safeFoods));
  localStorage.setItem("triggerFoods", JSON.stringify(triggerFoods));
  localStorage.setItem("welcomeCompleted", "true");
  showPage("main");
}

// Autocomplete for welcome screen
function setupWelcomeAutocomplete() {
  const input = document.getElementById("welcomeInput");
  const suggestions = document.getElementById("welcomeSuggestions");
  const chips = document.getElementById("welcomeChips");

  input.addEventListener("input", () => {
    const val = input.value.toLowerCase().trim();
    suggestions.innerHTML = "";
    if (!val) return;
    fuzzyMatch(val, ingredientList).forEach(m => {
      const div = document.createElement("div");
      div.className = "autocomplete-suggestion";
      div.innerHTML = m.replace(new RegExp(`(${val})`, 'i'), '<strong>$1</strong>');
      div.onclick = () => {
        const chip = document.createElement("div");
        chip.className = "chip";
        chip.textContent = m;
        const safeBtn = document.createElement("button");
        safeBtn.textContent = "Safe";
        safeBtn.onclick = (e) => {
          e.stopPropagation();
          if (!safeFoods.includes(m)) safeFoods.push(m);
          chip.remove();
        };
        const triggerBtn = document.createElement("button");
        triggerBtn.textContent = "Trigger";
        triggerBtn.onclick = (e) => {
          e.stopPropagation();
          if (!triggerFoods.includes(m)) triggerFoods.push(m);
          chip.remove();
        };
        chip.append(" ", safeBtn, triggerBtn);
        chips.appendChild(chip);
        input.value = "";
        suggestions.innerHTML = "";
      };
      suggestions.appendChild(div);
    });
  });
}

// Autocomplete for food logging
function setupMainAutocomplete() {
  const input = document.getElementById("ingredientInput");
  const suggestions = document.getElementById("suggestions");
  const chips = document.getElementById("chips");

  input.addEventListener("input", () => {
    const val = input.value.toLowerCase().split(/, */).pop().trim();
    suggestions.innerHTML = "";
    if (!val || !ingredientList.length) return;
    fuzzyMatch(val, ingredientList).forEach(m => {
      const div = document.createElement("div");
      div.className = "autocomplete-suggestion";
      div.innerHTML = m.replace(new RegExp(`(${val})`, 'i'), '<strong>$1</strong>');
      div.onclick = () => {
        if (!selectedIngredients.includes(m)) {
          selectedIngredients.push(m);
          const chip = document.createElement("span");
          chip.className = "chip";
          chip.textContent = m;
          chip.onclick = () => {
            selectedIngredients = selectedIngredients.filter(x => x !== m);
            chip.remove();
          };
          chips.appendChild(chip);
        }
        input.value = "";
        suggestions.innerHTML = "";
      };
      suggestions.appendChild(div);
    });
  });
}

let currentRecipeIngredients = [];

// Autocomplete for recipe creation
function setupRecipeAutocomplete() {
  const input = document.getElementById("recipeIngredientInput");
  const suggestions = document.getElementById("recipeSuggestions");
  const chips = document.getElementById("recipeChips");

  input.addEventListener("input", () => {
    const val = input.value.toLowerCase().split(/, */).pop().trim();
    suggestions.innerHTML = "";
    if (!val || !ingredientList.length) return;
    fuzzyMatch(val, ingredientList).forEach(m => {
      const div = document.createElement("div");
      div.className = "autocomplete-suggestion";
      div.innerHTML = m.replace(new RegExp(`(${val})`, 'i'), '<strong>$1</strong>');
      div.onclick = () => {
        if (!currentRecipeIngredients.includes(m)) {
          currentRecipeIngredients.push(m);
          const chip = document.createElement("span");
          chip.className = "chip";
          chip.textContent = m;
          chip.onclick = () => {
            currentRecipeIngredients = currentRecipeIngredients.filter(x => x !== m);
            chip.remove();
          };
          chips.appendChild(chip);
        }
        input.value = "";
        suggestions.innerHTML = "";
      };
      suggestions.appendChild(div);
    });
  });
}

// Save food log
function saveFood() {
  const time = document.getElementById("foodTime").value;
  if (!selectedIngredients.length || !time) return alert("Add ingredients and time.");
  const logs = JSON.parse(localStorage.getItem("foodLogs") || "[]");
  logs.push({ ingredients: selectedIngredients.slice(), time });
  localStorage.setItem("foodLogs", JSON.stringify(logs));
  selectedIngredients = [];
  document.getElementById("chips").innerHTML = "";
  document.getElementById("foodTime").value = "";
  alert("Food saved.");
  showPage("main");
}

//Save recipe
function saveRecipe() {
  const name = document.getElementById("recipeNameInput").value.trim();
  if (!name || currentRecipeIngredients.length === 0) {
    alert("Please provide a recipe name and ingredients.");
    return;
  }
  const recipes = JSON.parse(localStorage.getItem("recipes") || "[]");
  recipes.push({ name, ingredients: currentRecipeIngredients.slice() });
  localStorage.setItem("recipes", JSON.stringify(recipes));
  currentRecipeIngredients = [];
  document.getElementById("recipeNameInput").value = "";
  document.getElementById("recipeChips").innerHTML = "";
  renderRecipeList();
  alert("Recipe saved.");
}

//render recipes
function renderRecipeList() {
  const list = document.getElementById("recipeList");
  list.innerHTML = "";
  const recipes = JSON.parse(localStorage.getItem("recipes") || "[]");
  recipes.forEach(recipe => {
    const li = document.createElement("li");
    li.textContent = `${recipe.name} (${recipe.ingredients.join(", ")})`;
    list.appendChild(li);
  });
}

// Render symptom sliders
const symptomsList = ["Abdominal pain", "Diarrhea", "Fatigue", "Bloating", "Joint pain", "Mouth sores", "Fever", "Constipation", "Nausea"];
const container = document.getElementById("symptomContainer");
function renderSymptoms() {
  container.innerHTML = "";
  symptomsList.forEach(sym => {
    const wrapper = document.createElement("div");
    const cb = document.createElement("input");
    cb.type = "checkbox"; cb.id = `chk-${sym}`;
    const lb = document.createElement("label");
    lb.htmlFor = cb.id; lb.textContent = ` ${sym}`;
    const severityDiv = document.createElement("div");
    severityDiv.className = "severity hidden";
    const slider = document.createElement("input");
    slider.type = "range"; slider.min = 0; slider.max = 5; slider.value = 0;
    const out = document.createElement("span");
    out.textContent = "0";
    slider.oninput = () => out.textContent = slider.value;
    severityDiv.append("Severity: ", slider, out);
    cb.onchange = () => severityDiv.classList.toggle("hidden", !cb.checked);
    wrapper.append(cb, lb, severityDiv);
    container.appendChild(wrapper);
  });
}
renderSymptoms();

// Save symptom log
function saveSymptoms() {
  const time = document.getElementById("symptomTime").value;
  if (!time) return alert("Enter symptom time.");
  const selected = [];
  symptomsList.forEach(sym => {
    const cb = document.getElementById(`chk-${sym}`);
    if (cb.checked) {
      const slider = cb.parentNode.querySelector("input[type=range]");
      selected.push({ symptom: sym, severity: parseInt(slider.value) });
    }
  });
  if (!selected.length) return alert("Select symptoms.");
  const logs = JSON.parse(localStorage.getItem("symptomLogs") || "[]");
  logs.push({ time, symptoms: selected });
  localStorage.setItem("symptomLogs", JSON.stringify(logs));
  document.getElementById("symptomTime").value = "";
  renderSymptoms();
  alert("Symptoms saved.");
  showPage("main");
}

// Load settings page
function loadSettings() {
  const safe = JSON.parse(localStorage.getItem("safeFoods") || "[]");
  const trigger = JSON.parse(localStorage.getItem("triggerFoods") || "[]");
  const safeList = document.getElementById("safeList");
  const triggerList = document.getElementById("triggerList");
  safeList.innerHTML = triggerList.innerHTML = "";
  safe.forEach(f => {
    const li = document.createElement("li");
    li.textContent = f;
    safeList.appendChild(li);
  });
  trigger.forEach(f => {
    const li = document.createElement("li");
    li.textContent = f;
    triggerList.appendChild(li);
  });
}

// On load: check if user finished welcome
window.addEventListener("load", () => {
  const welcomeCompleted = localStorage.getItem("welcomeCompleted");
  if (welcomeCompleted === "true") {
    showPage("main");
  } else {
    showPage("welcome");
  }
});

// Export Food CSV
async function exportFoodCSV() {
  const foodLogs = JSON.parse(localStorage.getItem("foodLogs") || "[]");
  if (!foodLogs.length) {
    alert("No food logs to export.");
    return false;
  }

  try {
    const response = await fetch('ingredients.csv');
    const csvText = await response.text();
    const results = Papa.parse(csvText, { header: true, skipEmptyLines: true });
    const ingredientsMap = {};
    results.data.forEach(row => {
      const desc = row.Description?.toLowerCase();
      if (desc) ingredientsMap[desc] = row;
    });

    const headers = ["Time", ...Object.keys(results.data[0])];
    const rows = [headers];

    foodLogs.forEach(entry => {
      entry.ingredients.forEach(ing => {
        const data = ingredientsMap[ing.toLowerCase()];
        if (data) {
          const row = [entry.time, ...headers.slice(1).map(h => data[h] || "")];
          rows.push(row);
        }
      });
    });

    const csv = rows.map(r => r.map(x => `"${x}"`).join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "food_log.csv";
    a.click();
    URL.revokeObjectURL(a.href);
    return true;
  } catch (error) {
    alert("Error exporting food log.");
    console.error(error);
    return false;
  }
}

// Export Symptom CSV
function exportSymptomCSV() {
  const symptomLogs = JSON.parse(localStorage.getItem("symptomLogs") || "[]");
  if (!symptomLogs.length) {
    alert("No symptom logs to export.");
    return false;
  }

  const rows = [["Time", "Symptom", "Severity"]];
  symptomLogs.forEach(entry => {
    entry.symptoms.forEach(sym => {
      rows.push([entry.time, sym.symptom, sym.severity]);
    });
  });

  const csv = rows.map(r => r.map(x => `"${x}"`).join(",")).join("\n");
  const blob = new Blob([csv], { type: "text/csv" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "symptom_log.csv";
  a.click();
  URL.revokeObjectURL(a.href);
  return true;
}

// Consolidated export function to export both CSVs one after another
async function exportAllCSVs() {
  const foodExported = await exportFoodCSV();
  const symptomExported = exportSymptomCSV();
  // No additional alert needed since each export alerts on no data
}

function showLogs() {
  const foodLogs = JSON.parse(localStorage.getItem("foodLogs") || "[]");
  const symptomLogs = JSON.parse(localStorage.getItem("symptomLogs") || "[]");

  const foodContainer = document.getElementById("foodLogsTableContainer");
  const symptomContainer = document.getElementById("symptomLogsTableContainer");

  // Build food logs table
  if (foodLogs.length === 0) {
    foodContainer.innerHTML = "<p>No food logs recorded.</p>";
  } else {
    let foodHtml = `<table><thead><tr><th>Time</th><th>Ingredients</th></tr></thead><tbody>`;
    foodLogs.forEach(entry => {
      foodHtml += `<tr><td>${entry.time}</td><td>${entry.ingredients.join(", ")}</td></tr>`;
    });
    foodHtml += "</tbody></table>";
    foodContainer.innerHTML = foodHtml;
  }

  // Build symptom logs table
  if (symptomLogs.length === 0) {
    symptomContainer.innerHTML = "<p>No symptom logs recorded.</p>";
  } else {
    let symptomHtml = `<table><thead><tr><th>Time</th><th>Symptom</th><th>Severity</th></tr></thead><tbody>`;
    symptomLogs.forEach(entry => {
      entry.symptoms.forEach(sym => {
        symptomHtml += `<tr><td>${entry.time}</td><td>${sym.symptom}</td><td>${sym.severity}</td></tr>`;
      });
    });
    symptomHtml += "</tbody></table>";
    symptomContainer.innerHTML = symptomHtml;
  }

  document.getElementById("logsModal").style.display = "block";
}

// Close Logs modal
function closeLogs() {
  document.getElementById("logsModal").style.display = "none";
}

//create recipe dropdown on food page
function populateRecipeDropdown() {
  const dropdown = document.getElementById("recipeDropdown");
  dropdown.innerHTML = '<option value="">-- Select a Recipe --</option>';
  const recipes = JSON.parse(localStorage.getItem("recipes") || "[]");
  recipes.forEach((r, index) => {
    const opt = document.createElement("option");
    opt.value = index;
    opt.textContent = r.name;
    dropdown.appendChild(opt);
  });

  dropdown.onchange = function () {
    const recipes = JSON.parse(localStorage.getItem("recipes") || "[]");
    const selected = recipes[parseInt(this.value)];
    if (selected) {
      selected.ingredients.forEach(ing => {
        if (!selectedIngredients.includes(ing)) {
          selectedIngredients.push(ing);
          const chip = document.createElement("span");
          chip.className = "chip";
          chip.textContent = ing;
          chip.onclick = () => {
            selectedIngredients = selectedIngredients.filter(x => x !== ing);
            chip.remove();
          };
          document.getElementById("chips").appendChild(chip);
        }
      });
      this.value = "";
    }
  };
}

//fuzzy search
function fuzzyMatch(input, list, limit = 10) {
  const val = input.toLowerCase();
  return list
    .map(item => {
      const index = item.indexOf(val);
      const score = index === -1 ? Infinity : index; // Lower is better
      return { item, score };
    })
    .filter(entry => entry.score !== Infinity)
    .sort((a, b) => a.score - b.score)
    .slice(0, limit)
    .map(entry => entry.item);
}

</script>

</body>
</html>
